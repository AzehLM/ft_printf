README:     légende:

- les / et x je vous laisse faire vos propres recherches.
+ j'ai pas l'intention de faire tous les bonus alors il y a dans mes notes l'idée générale du fonctionnement de printf
+ encore une fois c'est des notes c'est normal que ce soit le bordel (+ j'ai pas fais en sorte que ce soit beau non plus)


PARTIE SANS BONUS:

1 - printf va ecrire char par char la chaine en parametre jusqu'a ce quelle trouve un %

2 - si un % est trouve, check % + 1 qui sera le type du premier argument de la variable

3 - selon ce quil y a apres le %, different type de conversion

4 - une fois ecrit on avance dans la chaine en param et on ecrit encore jusqu'à trouver un autre % ou que la chaine soit terminée '\0'

5 - printf return le nombre total de char affiches.



--- to remove : own functions name + detailed descriptions ---


---
Types que je dois gerer avec les values 
que jenvoie a chaque fonction de conversion 
en utilisant x(x, x);

'c' == / == function_name
'p' == / == function_name (voir print memory)
's' == / == function_name
'd' ou 'i' == / = function_name
'u' == / : function_name
'x' == / : function_name
'X' == / : function_name

par exemple :

x
---

---
CHAQUE FONCTION DE CONVERTION ECRIT ET RETURN UN COUNTEUR DU NOMBRE DE CHAR PRINT SUR LA STDOUT
en gros : count += write();
			return (count);


EDGE CASE:
1 - str : pour x return 'x';
2 - ptr : pour x return 'x';


GESTION DERREUR ? ;) wink

RETURN printf:

TEST FOR %c : a
TEST FOR %s : string
TEST FOR %p : 0x7ffccdb9d468 -> /!\ ;) ;)
TEST FOR %d : 42
TEST FOR %i : 24
TEST FOR %u : 4294967295
TEST FOR %x : ff
TEST FOR %X : FF



TEST AND EXEMPLES FOR BONUS PART :

    // Le flag '#' force l'affichage du préfixe 0x pour hexa
    printf("Hexadécimal avec #: %#x\n", 255);    // Affiche: 0xff
    printf("Hexadécimal sans #: %x\n", 255);     // Affiche: ff

    // Le flag '+' force l'affichage du signe pour les nombres positifs
    printf("Positif avec +: %+d\n", 42);         // Affiche: +42
    printf("Positif sans +: %d\n", 42);          // Affiche: 42
    printf("Négatif avec +: %+d\n", -42);        // Affiche: -42
    printf("Négatif sans +: %d\n", -42);         // Affiche: -42

    // Le flag espace ajoute un espace avant les nombres positifs
    printf("Positif avec espace: % d\n", 42);    // Affiche:  42
    printf("Positif sans espace: %d\n", 42);     // Affiche: 42
    printf("Négatif avec espace: % d\n", -42);   // Affiche: -42
    printf("Négatif sans espace: %d\n", -42);    // Affiche: -42


BONUS IMPLEMENTATION :

Tout tourne autour du parsing, il faut reproduire le comportement des flags suivants :

FLAG '#' :

Pour les conversions x et X, un resultat non null prefix 0x (%#x)ou 0X (%#X).
Il peut y avoir une multitude de # devant un parametre, cela n'affecte pas le nombre de x a afficher.

FLAG ' ' :

Pour les convertions de type signed (int), un espace est mit devant la valeur numerique 
du retour de %i et %d si la valeur est positive, pas d'ajout si la valeur est negative.
L'objectif est de laisser une 'place' pour le signe + ou - si besoin.
D'ou le fait que le FLAG + prenne le dessus sur lespace si les deux sont mis ensemble. (voir next flag)

FLAG '+' :

Fais en sorte que le signe de la value affichée à l'utilisation de printf soit affiché avant le nombre. 
Par defaut, seulement le signe - est affiché (voir Mandatory part).
Si un '+' et un ' ' sont combiner, le + prend le dessus. 
(erreur compilation de toute facon, les deux flags ne peuvent etre utilise ensemble)


NEXT STEP : 

- xx
- xx
- xx


DEEP INSIDE PARSING :
- x


%d (décimal signé) :
" " (espace) : ajoute un espace avant les nombres positifs
"+" : force l'affichage du signe (+ ou -)
Combinaison "+ " : "+" prend priorité sur l'espace

%i (identique à d) :
" " (espace) : ajoute un espace avant les nombres positifs
"+" : force l'affichage du signe (+ ou -)
Combinaison "+ " : "+" prend priorité sur l'espace

x (hexadécimal minuscule) :
"#" : ajoute "0x" avant le nombre

X (hexadécimal majuscule) :
"#" : ajoute "0X" avant le nombre

En résumé :
"#" fonctionne uniquement avec x et X
" " (espace) fonctionne uniquement avec d et i
"+" fonctionne uniquement avec d et i
La combinaison des flags n'est possible que pour d et i avec "+ "



Gestion des FLAGS bonus avec une structure :
- Creation d'une structure composé de booléens pour chaque FLAG voulant etre testé :


+ avantage : code modulable

typedef struct	s_list
{
	bool	flag1;
	bool	flag2;
	bool	flagx...;
}	t_bool;

- x

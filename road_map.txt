PARTIE SANS BONUS:

1 - printf va ecrire char par char la chaine en parametres jusqu'a ce quelle trouve un %

2 - si un % est trouve, check % + 1 qui sera le type du premier argument de la variable

3 - selon ce quil y a apres le %, different type de conversion

4 - une fois ecrit on avance dans le chaine en parametre et on ecrit encore jusqua trouver un autre % ou que la chaine soit terminée '\0'

5 - printf return le nombre total de char affiches.


---
int printf = return len de la string en parametre
- a besoin de va_list arguments;
- a besoin de len, la valeur a return;

on va_start pour initialiser la listes darguments

len = fonction qui va executer tout le reste :
- la lecture/parsing de la string qui ira faire les conversion en fonction des types de formats reconnus (cette fonction prendra en parametre la string et les args);

on va_end la lecture de la liste des arguments lorsque lon est au bout de la string format

on return len (return value de printf)
---


---
fonction de print de format :
prend la string en param et la structure va_list

cette fonction parcours la chaine de format 
et traite les differents type de conversion rencontres, 
si un % est rencontre :
- on check % + 1 avec strchr et la liste des 
parametres que lont veut check

-- si on en trouve un on donne a une autre 
fonction la position et la struct qui identifiera 
largument et le traitera (ft_convert_args)

- sinon si on a eu 2 %% daffiler on affiche %
sinon on affiche le charactere normalement
la fonction return len pour ft_printf.
---


---
strchr : classique, au choix reprendre celle de la lib ou en faire une custom.
---


---
fonction didentification de format, elle prend en parametre 
le type a convertir (convert), et la struc arguments :
dans cette fonction on declare un counteur qui 
sera return et est le nombre de char afficher sur la stdout

les types que je dois gerer avec les values 
que jenvoie a chaque fonction de conversion 
en utilisant va_arg(arguments, type);

'c' == int; == putchar
'p' == void * == ptr conversion (voir print memory)
's' == char * == putstr classique
'd' ou 'i' == int = base 10 conversion
'u' == unsigned int : unsigned int conversion
'x' == unsigned int : puthexa lowercase
'X' == unsigned int : puthexa uppercase

par exemple :

if (convert == 'c')
	counteur += putchar(va_arg(arguments, int));
---

---
CHAQUE FONCTION DE CONVERTION ECRIT ET RETURN UN COUNTEUR DU NOMBRE DE CHAR PRINT SUR LA STDOUT
en gros : count += write();
			return (count);

un cas particulier a gerer : si %s, NULL on doit ecrire '(null)'

CHECK AVEC VRAI FONCTION printf

GESTION DERREUR ?

pour string null return '(null)'
pour pointeur nill return '(nill)';

RETURN printf:

TEST FOR %c : int a = 'a' : a || char b = 'a' : a 
TEST FOR %s : string
TEST FOR %p : 0x7ffccdb9d468
TEST FOR %d : 42
TEST FOR %i : 24
TEST FOR %u : 4294967295
TEST FOR %x : ff
TEST FOR %X : FF



TEST AND EXEMPLES FOR BONUS PART :

    // Le flag '#' force l'affichage du préfixe 0x pour hexa
    printf("Hexadécimal avec #: %#x\n", 255);    // Affiche: 0xff
    printf("Hexadécimal sans #: %x\n", 255);     // Affiche: ff

    // Le flag '+' force l'affichage du signe pour les nombres positifs
    printf("Positif avec +: %+d\n", 42);         // Affiche: +42
    printf("Positif sans +: %d\n", 42);          // Affiche: 42
    printf("Négatif avec +: %+d\n", -42);        // Affiche: -42
    printf("Négatif sans +: %d\n", -42);         // Affiche: -42

    // Le flag espace ajoute un espace avant les nombres positifs
    printf("Positif avec espace: % d\n", 42);    // Affiche:  42
    printf("Positif sans espace: %d\n", 42);     // Affiche: 42
    printf("Négatif avec espace: % d\n", -42);   // Affiche: -42
    printf("Négatif sans espace: %d\n", -42);    // Affiche: -42


BONUS IMPLEMENTATION :

Tout tourne autour du parsing, il faut reproduire le comportement des flags suivants :

FLAG '#' :

Pour les conversions x et X, un resultat non null prefix 0x (%#x)ou 0X (%#X).
Il peut y avoir une multitude de # devant un parametre, cela n'affecte pas le nombre de x a afficher.

FLAG ' ' :

Pour les convertions de type signed (int), un espace est mit devant la valeur numerique 
du retour de %i et %d si la valeur est positive, pas d'ajout si la valeur est negative.
L'objectif est de laisser une 'place' pour le signe + ou - si besoin.
D'ou le fait que le FLAG + prenne le dessus sur lespace si les deux sont mis ensemble. (voir next flag)

FLAG '+' :

Fais en sorte que le signe de la value affichee a lutilisation de printf soit afficher avant le nombre. 
Par defaut, seulement le signe - est affiche (voir Mandatory part).
Si un '+' et un ' ' sont combiner, le + prend le dessus. 
(erreur compilation de toute facon, les deux flags ne peuvent etre utilise ensemble)


NEXT STEP : 

- Definir un ordre de priorite dans le parsing
- Faire en sorte que l'on puisse lire n FLAG
- Reproduire les comportements des flags


DEEP INSIDE PARSING :
- check si format est "dixX"


%d (décimal signé) :
" " (espace) : ajoute un espace avant les nombres positifs
"+" : force l'affichage du signe (+ ou -)
Combinaison "+ " : "+" prend priorité sur l'espace

%i (identique à d) :
" " (espace) : ajoute un espace avant les nombres positifs
"+" : force l'affichage du signe (+ ou -)
Combinaison "+ " : "+" prend priorité sur l'espace

x (hexadécimal minuscule) :
"#" : ajoute "0x" avant le nombre

X (hexadécimal majuscule) :
"#" : ajoute "0X" avant le nombre

En résumé :
"#" fonctionne uniquement avec x et X
" " (espace) fonctionne uniquement avec d et i
"+" fonctionne uniquement avec d et i
La combinaison des flags n'est possible que pour d et i avec "+ "


format #####x  


possibilites:

if format[i] == % && format[i + 1] == #

while format[i] != x || format[i] != X
    i++;
    ft_convert_args(format[i], args)


Gestion des FLAGS bonus avec une structure :
- Creation d'une structure composé de booléens pour chaque FLAG voulant etre testé :

typedef struct	s_list
{
	bool	flag1;
	bool	flag2;
	bool	flagx...;
}	t_bool;

- La suite du parsing est simple, a chaque flag rencontré 
  on set le booléen a TRUE jusqu'à ce que l'on tombe sur un identifieur.
- traitement de l'identifieur en fonction des flags
- reset des booléens a 0 

